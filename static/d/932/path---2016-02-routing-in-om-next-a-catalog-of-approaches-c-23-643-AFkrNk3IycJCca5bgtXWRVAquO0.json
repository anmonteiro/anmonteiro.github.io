{"data":{"markdownRemark":{"excerpt":"\nAlthough a standard routing solution is an orthogonal concern to Om Next's design and, at the time of this writing, there is still [ongoing development](https://github.com/omcljs/om/wiki/Routing-Support) with the objective of introducing simpler routing hooks, there are already several ways in which one can add proper route navigation to an Om Next app. This post aims to decrease the general community confusion around this topic by introducing a variety of different approaches that can be used to integrate routing in an Om Next app.\n\n","html":"<p>Although a standard routing solution is an orthogonal concern to Om Next's design and, at the time of this writing, there is still <a href=\"https://github.com/omcljs/om/wiki/Routing-Support\">ongoing development</a> with the objective of introducing simpler routing hooks, there are already several ways in which one can add proper route navigation to an Om Next app. This post aims to decrease the general community confusion around this topic by introducing a variety of different approaches that can be used to integrate routing in an Om Next app.</p>\n<!--more-->\n<div class=\"message\">\n  <strong>Note:</strong> I've recently developed <a href=\"https://github.com/anmonteiro/compassus\">Compassus</a>, a routing library that automates all the pain of integrating routing in an Om Next application. Check the <a href=\"2016/06/the-quest-for-a-unified-routing-solution-in-om-next\">announcement post</a>!\n</div>\n<h2><strong>The end goal</strong></h2>\n<p>The example we will be working with throughout this post is presented below. It resembles a normal web application that has two routes: the <strong>Home</strong> page and an <strong>About</strong> page. Feel free to play with the links in the example's sidebar, and verify that the current route is updated, as well as the page's main content.</p>\n<div style=\"margin-bottom: 20px;\">\n  <div id=\"dp-card-1\"></div>\n</div>\n<h2><strong>The Catalog</strong></h2>\n<p>This section will demonstrate different ways of accomplishing the behavior shown in the example above, namely using queries with unions, using <code class=\"language-text\">set-query!</code> and by leveraging the power of <code class=\"language-text\">subquery</code>. For each one, we will see the components, their queries and the parsing logic that is necessary to accomplish such behavior. The render logic falls out of the scope of this writing and is only shown when strictly necessary, for the sake of brevity. The <code class=\"language-text\">Home</code> and <code class=\"language-text\">About</code> components are common to all examples and are shown below. They each declare which properties they need from the state in their queries.</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">(</span>defui Home\n  static om/IQuery\n  <span class=\"token punctuation\">(</span>query <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">[</span><span class=\"token operator\">:home</span>/title <span class=\"token operator\">:home</span>/content<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span>defui About\n  static om/IQuery\n  <span class=\"token punctuation\">(</span>query <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">[</span><span class=\"token operator\">:about</span>/title <span class=\"token operator\">:about</span>/content<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>We also define helpers that map routes to their components and the factories that create instances of such components:</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">def</span> route->component\n  <span class=\"token punctuation\">{</span><span class=\"token operator\">:app</span>/home Home\n   <span class=\"token operator\">:app</span>/about About<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">def</span> route->factory\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">zipmap</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">keys</span> route->component<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">map</span> om/factory <span class=\"token punctuation\">(</span><span class=\"token keyword\">vals</span> route->component<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Throughout these sections, we will use the same <code class=\"language-text\">app-state</code> and the same way of representing routes. The state is shown below. We keep the current route, which in our case is the <strong>Home</strong> route, and the data we present in this and the <strong>About</strong> route.</p>\n<div style=\"margin-bottom: 20px;\">\n  <div id=\"dp-card-2\"></div>\n</div>\n<p>Our routes are represented by Om Next <code class=\"language-text\">idents</code>. Since we don't have any route that refers to an element in a collection, the second element of our routes will always be the <code class=\"language-text\">_</code> character. However, if we had <em>e.g.</em> a list of people in our app, showing the profile of the person identified by the ID 3 would be denoted by the route <code class=\"language-text\">[:app/people 3]</code>.</p>\n<h3><strong>Routing with Union Queries</strong></h3>\n<p>Our first example takes advantage of the expressiveness that union queries provide to declare hetereogenous user interfaces. Our <code class=\"language-text\">Root</code> component's query needs the current route, expressed by <code class=\"language-text\">:app/route</code> in its query, and the queries for all the components for which there is a route. Our simplistic case only has two routes, so the generated query for <code class=\"language-text\">Root</code> will be:</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">[</span><span class=\"token operator\">:app</span>/route\n<span class=\"token punctuation\">{</span><span class=\"token operator\">:route</span>/data <span class=\"token punctuation\">{</span><span class=\"token operator\">:app</span>/home <span class=\"token punctuation\">[</span><span class=\"token operator\">:home</span>/title <span class=\"token operator\">:home</span>/content<span class=\"token punctuation\">]</span>\n              <span class=\"token operator\">:app</span>/about <span class=\"token punctuation\">[</span><span class=\"token operator\">:about</span>/title <span class=\"token operator\">:about</span>/content<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>The <code class=\"language-text\">Root</code> component chooses which sub-component to render based on the current route found in its props. A rather simplistic <code class=\"language-text\">render</code> method for our root component is included in the component definition below:</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">(</span>defui Root\n  static om/IQuery\n  <span class=\"token punctuation\">(</span>query <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">[</span><span class=\"token operator\">:app</span>/route\n    <span class=\"token punctuation\">{</span><span class=\"token operator\">:route</span>/data <span class=\"token punctuation\">(</span><span class=\"token keyword\">zipmap</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">keys</span> route->component<span class=\"token punctuation\">)</span>\n                   <span class=\"token punctuation\">(</span><span class=\"token keyword\">map</span> om/get-query <span class=\"token punctuation\">(</span><span class=\"token keyword\">vals</span> route->component<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  Object\n  <span class=\"token punctuation\">(</span>render <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span>app/route route/data<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">(</span>om/props this<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>route->factory <span class=\"token punctuation\">(</span><span class=\"token keyword\">first</span> route<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The parser code has two responsibilites: the <code class=\"language-text\">read</code> function must return only the data for the current route, and the <code class=\"language-text\">mutate</code> function needs to know how to change the app's route. An example of how this could be achieved is presented in the snippet below.</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">defmulti</span> <span class=\"token keyword\">read</span> om/dispatch<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">defmulti</span> mutate om/dispatch<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">defmethod</span> <span class=\"token keyword\">read</span> <span class=\"token operator\">:route</span>/data\n   <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span>state query<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> k _<span class=\"token punctuation\">]</span>\n   <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>st @state\n         route <span class=\"token punctuation\">(</span><span class=\"token keyword\">get</span> st <span class=\"token operator\">:app</span>/route<span class=\"token punctuation\">)</span>\n         route <span class=\"token punctuation\">(</span>cond-> route\n                 <span class=\"token punctuation\">(</span><span class=\"token keyword\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">second</span> route<span class=\"token punctuation\">)</span> '_<span class=\"token punctuation\">)</span> <span class=\"token keyword\">pop</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n     <span class=\"token comment\">;; since the route is an `ident`, it could also</span>\n     <span class=\"token comment\">;; be passed as the second argument to `db->tree`</span>\n     <span class=\"token comment\">;; if our data was normalized</span>\n     <span class=\"token punctuation\">{</span><span class=\"token operator\">:value</span> <span class=\"token punctuation\">(</span>get-in st route<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">defmethod</span> <span class=\"token keyword\">read</span> <span class=\"token operator\">:app</span>/route\n   <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span>state query<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> k _<span class=\"token punctuation\">]</span>\n   <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>st @state<span class=\"token punctuation\">]</span>\n     <span class=\"token punctuation\">{</span><span class=\"token operator\">:value</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">get</span> st k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">defmethod</span> mutate <span class=\"token operator\">'change</span>/route!\n  <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> _ <span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span>route<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">{</span><span class=\"token operator\">:value</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">:app</span>/route<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span>\n   <span class=\"token operator\">:action</span> #<span class=\"token punctuation\">(</span>swap! state <span class=\"token keyword\">assoc</span> <span class=\"token operator\">:app</span>/route route<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Nothing else is needed. Routing will work once you plumb everything together with the help of the reconciler.</p>\n<h3><strong>Routing with <code class=\"language-text\">set-query!</code></strong></h3>\n<p>In the previous example, we needed to include every subcomponent's query in the <code class=\"language-text\">Root</code>'s union query so that the query for the current route was already in a union branch when the route changed. In this example we will see that we can implement routing by including the current route's query on demand, only when the route changes.</p>\n<p>A simplistic <code class=\"language-text\">Root</code> component for this case looks like the one below. We have the current route's query in the <code class=\"language-text\">:route/data</code> parameter, which is initially empty. Before the component first mounts, we swap in the query for the initial route.</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">(</span>defui Root\n  static om/IQueryParams\n  <span class=\"token punctuation\">(</span>params <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">{</span><span class=\"token operator\">:route</span>/data <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  static om/IQuery\n  <span class=\"token punctuation\">(</span>query <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    '<span class=\"token punctuation\">[</span><span class=\"token operator\">:app</span>/route <span class=\"token punctuation\">{</span><span class=\"token operator\">:route</span>/data ?route/data<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  Object\n  <span class=\"token punctuation\">(</span>componentWillMount <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span>app/route<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">(</span>om/props this<span class=\"token punctuation\">)</span>\n          initial-query <span class=\"token punctuation\">(</span>om/get-query <span class=\"token punctuation\">(</span>route->component <span class=\"token punctuation\">(</span><span class=\"token keyword\">first</span> route<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">(</span>om/set-query! this <span class=\"token punctuation\">{</span><span class=\"token operator\">:params</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">:route</span>/data initial-query<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span>render <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span>app/route route/data<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">(</span>om/props this<span class=\"token punctuation\">)</span>\n          active-component <span class=\"token punctuation\">(</span><span class=\"token keyword\">get</span> route->factory <span class=\"token punctuation\">(</span><span class=\"token keyword\">first</span> route<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">(</span>active-component data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Because the root component's query is now changed on demand, the only modification that we need to introduce in our parser code is a call to <code class=\"language-text\">set-query!</code> in the <code class=\"language-text\">change/route!</code> mutation, so that we change the root query to include the new route's needed information. The complete parser code is presented below.</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">defmulti</span> <span class=\"token keyword\">read</span> om/dispatch<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">defmulti</span> mutate om/dispatch<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">defmethod</span> <span class=\"token keyword\">read</span> <span class=\"token operator\">:route</span>/data\n  <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">]</span> <span class=\"token operator\">:as</span> env<span class=\"token punctuation\">}</span> k _<span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>st @state\n        route <span class=\"token punctuation\">(</span><span class=\"token keyword\">first</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">:app</span>/route st<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">{</span><span class=\"token operator\">:value</span> <span class=\"token punctuation\">(</span>get-in st <span class=\"token punctuation\">[</span>route<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">defmethod</span> <span class=\"token keyword\">read</span> <span class=\"token operator\">:app</span>/route\n   <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span>state query<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> k _<span class=\"token punctuation\">]</span>\n   <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>st @state<span class=\"token punctuation\">]</span>\n     <span class=\"token punctuation\">{</span><span class=\"token operator\">:value</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">get</span> st k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">defmethod</span> mutate <span class=\"token operator\">'change</span>/route!\n  <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span>state component<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> _ <span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span>route<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">{</span><span class=\"token operator\">:value</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">:app</span>/route<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span>\n   <span class=\"token operator\">:action</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">fn</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n             <span class=\"token punctuation\">(</span>swap! state <span class=\"token keyword\">assoc</span> <span class=\"token operator\">:app</span>/route route<span class=\"token punctuation\">)</span>\n             <span class=\"token punctuation\">(</span>om/set-query! component\n               <span class=\"token punctuation\">{</span><span class=\"token operator\">:params</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">:route</span>/data <span class=\"token punctuation\">(</span>om/get-query <span class=\"token punctuation\">(</span>route->component <span class=\"token punctuation\">(</span><span class=\"token keyword\">first</span> route<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3><strong>Routing with <code class=\"language-text\">subquery</code></strong></h3>\n<p><code class=\"language-text\">subquery</code> is a nice little function that has been receiving very little attention in Om Next. It is, however, a very powerful construct that solves the routing problem for a bounded number of subviews in a very clean way <sup><sub>1</sub></sup>. All you really have to do it attach a React <code class=\"language-text\">ref</code> to the subviews. <code class=\"language-text\">subquery</code> takes care of the rest.</p>\n<p>Let's see an example. This approach pushes all the routing logic into the <code class=\"language-text\">query</code> function of the <code class=\"language-text\">Root</code> component. Our sub-components will be rendered with a <code class=\"language-text\">ref</code> which is exactly the keyword by which their route is identified. We use this knowledge in the <code class=\"language-text\">query</code> function to plug in the correct query at runtime.</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">(</span>defui Root\n  static om/IQuery\n  <span class=\"token punctuation\">(</span>query <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>subq-ref <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>om/component? this<span class=\"token punctuation\">)</span>\n                     <span class=\"token punctuation\">(</span><span class=\"token keyword\">-></span> <span class=\"token punctuation\">(</span>om/props this<span class=\"token punctuation\">)</span> <span class=\"token operator\">:app</span>/route <span class=\"token keyword\">first</span><span class=\"token punctuation\">)</span>\n                     <span class=\"token operator\">:app</span>/home<span class=\"token punctuation\">)</span>\n          subq-class <span class=\"token punctuation\">(</span><span class=\"token keyword\">get</span> route->component subq-ref<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">[</span><span class=\"token operator\">:app</span>/route <span class=\"token punctuation\">{</span><span class=\"token operator\">:route</span>/data <span class=\"token punctuation\">(</span>om/subquery this subq-ref subq-class<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  Object\n  <span class=\"token punctuation\">(</span>render <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span>app/route route/data<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">(</span>om/props this<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>route->factory <span class=\"token punctuation\">(</span><span class=\"token keyword\">first</span> route<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">assoc</span> data <span class=\"token operator\">:ref</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">first</span> route<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>In this case, the parser code is exactly the same as in the example of routing using union queries, and is not included again.</p>\n<h2><strong>Closing thoughts</strong></h2>\n<p>In this post, I've presented 3 different alternatives to approach routing in Om Next. I hope it helps you decide which one is the most useful for your use case. You can find the complete source code for the examples in this post <a href=\"https://github.com/anmonteiro/anmonteiro.github.io/tree/master/assets/cljs/om_next_routing\">here</a>.</p>\n<p>If you have any questions or suggestions, don't hesitate to contact me either on Twitter (<a href=\"https://twitter.com/_anmonteiro\">@_anmonteiro</a>) or by leaving a comment in the section below. As always, thanks for reading!</p>\n<script type=\"text/javascript\" src=\"/public/js/om_next_routing.js\"></script>\n<hr>\n<p><sup><sub>1</sub></sup> <sub>Note that this method will not be a clean solution if you want to route to arbitrary elements in a list, since the logic of adding <code class=\"language-text\">ref</code>s to every element in a list will soon become complex enough.</sub></p>","fields":{"title":"Routing in Om Next — a Catalog of Approaches","date":"22 Feb 2016","tags":["clojure","clojurescript","om"],"slug":"/2016/02/routing-in-om-next-a-catalog-of-approaches/","url":"https://anmonteiro.com/2016/02/routing-in-om-next-a-catalog-of-approaches/"}},"allPosts":{"edges":[{"node":{"fields":{"title":"Reason and the Language Server Protocol: The Landscape","slug":"/2018/11/reason-and-the-language-server-protocol-the-landscape/","tags":["reason","ocaml","emacs","editors"],"date":"17 Nov 2018"}}},{"node":{"fields":{"title":"The State of ClojureScript Compilation in Lumo","slug":"/2017/09/the-state-of-clojurescript-compilation-in-lumo/","tags":["clojure","clojurescript","lumo"],"date":"19 Sep 2017"}}},{"node":{"fields":{"title":"Shipping a (very simplistic) ReasonReact app","slug":"/2017/08/shipping-a-very-simplistic-reasonreact-app/","tags":["reason","ocaml"],"date":"20 Aug 2017"}}},{"node":{"fields":{"title":"On Lumo's Growth and Sustainability","slug":"/2017/05/on-lumos-growth-and-sustainability/","tags":["clojure","clojurescript","lumo"],"date":"01 May 2017"}}},{"node":{"fields":{"title":"Requiring Node.js modules from ClojureScript namespaces","slug":"/2017/03/requiring-node-js-modules-from-clojurescript-namespaces/","tags":["clojure","clojurescript","node","nodejs"],"date":"17 Mar 2017"}}},{"node":{"fields":{"title":"Compiling ClojureScript Projects Without the JVM","slug":"/2017/02/compiling-clojurescript-projects-without-the-jvm/","tags":["clojure","clojurescript","lumo"],"date":"21 Feb 2017"}}},{"node":{"fields":{"title":"The fastest Clojure REPL in the world","slug":"/2016/11/the-fastest-clojure-repl-in-the-world/","tags":["clojure","clojurescript","lumo"],"date":"09 Nov 2016"}}},{"node":{"fields":{"title":"ClojureScript `require` outside `ns`","slug":"/2016/10/clojurescript-require-outside-ns/","tags":["clojure","clojurescript"],"date":"02 Oct 2016"}}},{"node":{"fields":{"title":"Om Next internals: Incremental Rendering","slug":"/2016/09/om-next-internals-incremental-rendering/","tags":["clojure","clojurescript","om"],"date":"29 Sep 2016"}}},{"node":{"fields":{"title":"Om Next Server-Side Rendering","slug":"/2016/09/om-next-server-side-rendering/","tags":["clojure","clojurescript","om"],"date":"15 Sep 2016"}}},{"node":{"fields":{"title":"Om Next at Full Stack Fest 2016","slug":"/2016/09/om-next-at-full-stack-fest-2016/","tags":["talks","clojure","clojurescript","om"],"date":"14 Sep 2016"}}},{"node":{"fields":{"title":"Om Next and Bootstrapped ClojureScript","slug":"/2016/08/om-next-and-bootstrapped-clojurescript/","tags":["clojure","clojurescript","om"],"date":"24 Aug 2016"}}},{"node":{"fields":{"title":"ClojureScript `require` now supports `:rename`","slug":"/2016/08/clojurescript-require-now-supports-rename/","tags":["clojure","clojurescript"],"date":"10 Aug 2016"}}},{"node":{"fields":{"title":"The quest for a unified routing solution in Om Next","slug":"/2016/06/the-quest-for-a-unified-routing-solution-in-om-next/","tags":["clojure","clojurescript","om"],"date":"12 Jun 2016"}}},{"node":{"fields":{"title":"&apos;Clients in control&apos; — Om Next at Craft Conference 2016","slug":"/2016/05/clients-in-control-om-next-craft-conf-2016/","tags":["talks","clojure","clojurescript","om"],"date":"14 May 2016"}}},{"node":{"fields":{"title":"Routing in Om Next — a Catalog of Approaches","slug":"/2016/02/routing-in-om-next-a-catalog-of-approaches/","tags":["clojure","clojurescript","om"],"date":"22 Feb 2016"}}},{"node":{"fields":{"title":"Om Next meets Devcards — the full reloadable experience","slug":"/2016/02/om-next-meets-devcards-the-full-reloadable-experience/","tags":["clojure","clojurescript","om"],"date":"01 Feb 2016"}}},{"node":{"fields":{"title":"Writing Om Next Reloadable Code — A Checklist","slug":"/2016/01/writing-om-next-reloadable-code-a-checklist/","tags":["clojure","clojurescript","om"],"date":"21 Jan 2016"}}},{"node":{"fields":{"title":"An Exploration of Object Recursion Design Patterns with Om Next Recursive Queries - Part 2","slug":"/2016/01/exploration-patterns-om-next-part-2/","tags":["clojure","clojurescript","om"],"date":"09 Jan 2016"}}},{"node":{"fields":{"title":"An Exploration of Object Recursion Design Patterns with Om Next Recursive Queries - Part 1","slug":"/2016/01/exploration-patterns-om-next-part-1/","tags":["clojure","clojurescript","om"],"date":"07 Jan 2016"}}},{"node":{"fields":{"title":"Om Next Query Syntax Explained","slug":"/2016/01/om-next-query-syntax/","tags":["clojure","clojurescript","om"],"date":"04 Jan 2016"}}},{"node":{"fields":{"title":"Om Next Study Material","slug":"/2015/12/om-next-study-material/","tags":["clojure","clojurescript","om"],"date":"10 Dec 2015"}}},{"node":{"fields":{"title":"clj-isitup - a simple isitup.org API client","slug":"/2015/11/clj-isitup-a-simple-isitup-org-api-client/","tags":["clojure"],"date":"17 Nov 2015"}}},{"node":{"fields":{"title":"Hosting files on the cloud via GitHub Issues","slug":"/2015/09/hosting-files-on-the-cloud-via-github-issues/","tags":["git","GitHub"],"date":"26 Sep 2015"}}},{"node":{"fields":{"title":"Solving Closure Library's Html5history double event dispatch","slug":"/2015/09/solving-closure-librarys-html5history-double-event-dispatch/","tags":["clojure","clojurescript"],"date":"11 Sep 2015"}}},{"node":{"fields":{"title":"Setting up Heroku config variables with Clojure","slug":"/2015/09/setting-up-heroku-config-variables-with-clojure/","tags":["clojure","heroku"],"date":"03 Sep 2015"}}},{"node":{"fields":{"title":"Jekyll related posts revamped","slug":"/2015/08/jekyll-related-posts-revamped/","tags":["jekyll"],"date":"29 Aug 2015"}}},{"node":{"fields":{"title":"Custom subdomains in GitHub project pages","slug":"/2015/08/custom-subdomains-in-github-project-pages/","tags":["git","GitHub"],"date":"24 Aug 2015"}}},{"node":{"fields":{"title":"Grand opening","slug":"/2015/08/grand-opening/","tags":["lifestyle"],"date":"18 Aug 2015"}}},{"node":{"fields":{"title":"On OCaml and the JS platform","slug":"/2021/12/on-ocaml-and-the-js-platform/","tags":["reason","ocaml","rescript"],"date":"11 Dec 2021"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2016/02/routing-in-om-next-a-catalog-of-approaches/"}}