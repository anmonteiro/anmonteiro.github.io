{"data":{"markdownRemark":{"excerpt":"\nThe recent [landing of recursive union queries](https://github.com/omcljs/om/pull/562) in Om Next allows for defining recursive, heterogeneous data in a simple, expressive way. In a series of posts, I will explore how this conjugates with well-known Software Engineering structural design patterns that are based on object recursion. In this part 1 we will put together a simple component hierarchy that uses the [Composite](https://en.wikipedia.org/wiki/Composite_pattern) design pattern. Let's dig into it.\n\n","html":"<p>The recent <a href=\"https://github.com/omcljs/om/pull/562\">landing of recursive union queries</a> in Om Next allows for defining recursive, heterogeneous data in a simple, expressive way. In a series of posts, I will explore how this conjugates with well-known Software Engineering structural design patterns that are based on object recursion. In this part 1 we will put together a simple component hierarchy that uses the <a href=\"https://en.wikipedia.org/wiki/Composite_pattern\">Composite</a> design pattern. Let's dig into it.</p>\n<!--more-->\n<h2>The Composite design pattern</h2>\n<div style=\"max-width:75%;margin:15px auto 0;\">\n  <img src=\"https://cloud.githubusercontent.com/assets/661909/12181450/8858f8ac-b582-11e5-99e2-3c11f1913801.png\" alt=\"Composite design pattern\">\n</div>\n<p>The Composite is part of the design pattern collection in the <a href=\"https://en.wikipedia.org/wiki/Design_Patterns\">Gang of Four book</a>. Its purpose is to <strong>compose</strong> trees of objects that fulfill the same contract by building and iterating over them. The secret weapon here is that, while iterating, there is no need to know if we're working on a leaf node or an inner node — we can simply treat every node in the same way. Inner nodes will take care of iterating over their children in the process.</p>\n<h2>Our example</h2>\n<p>In our simplified example, we want to render a square that can arbitrarily contain other squares. Using the nomenclature in the above diagram, we need to define Om Next components for both the <code class=\"language-text\">Leaf</code> and the <code class=\"language-text\">Composite</code>. <code class=\"language-text\">Composite</code> components can have <code class=\"language-text\">children</code>, whereas <code class=\"language-text\">Leaf</code> components cannot. We will also have our version of <code class=\"language-text\">Component</code>, which aggregates the queries for both others, and dispatches rendering to them <sup><sub>1</sub></sup>.</p>\n<h3>The data</h3>\n<p>We start with the data below. Each square contains attributes for its width, height and color. Each item also has an <code class=\"language-text\">id</code>; this reveals helpful in normalizing the data.</p>\n<div style=\"margin-bottom: 20px;\">\n  <div id=\"dp-card-1\"></div>\n</div>\n<h3>The Om Next components</h3>\n<p>Our <code class=\"language-text\">Leaf</code> and <code class=\"language-text\">Composite</code> components are shown below <sup><sub>2</sub></sup>. Their queries are trivial, in the sense that they just declare the attributes we have talked about before. The only exception, which you might have not seen before, is the <code class=\"language-text\">{:children ...}</code> part. This is how we declare recursion in Om Next. Refer to my post about Om Next's <a href=\"2016/01/om-next-query-syntax\">query syntax</a> where I explain this and other bits in detail.</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">(</span>defui Leaf\n  static om/IQuery\n  <span class=\"token punctuation\">(</span>query <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    '<span class=\"token punctuation\">[</span><span class=\"token operator\">:id</span> <span class=\"token operator\">:width</span> <span class=\"token operator\">:height</span> <span class=\"token operator\">:color</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span>defui Composite\n  static om/IQuery\n  <span class=\"token punctuation\">(</span>query <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    '<span class=\"token punctuation\">[</span><span class=\"token operator\">:id</span> <span class=\"token operator\">:width</span> <span class=\"token operator\">:height</span> <span class=\"token operator\">:color</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">:children</span> <span class=\"token keyword\">..</span>.<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Now that we have declared our most concrete components, we need to declare the one that is analogous to the Component in the Composite pattern diagram. Our <code class=\"language-text\">Component</code> needs to aggregate the queries of the others, and declare its <code class=\"language-text\">Ident</code>, a unique key by which each data item is identified in our example. Besides defining an <code class=\"language-text\">id</code>, we could also have a the type of an item in our data; in our simple example this is not necessary as we know leaves can't have children. It looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">(</span>defui Component\n  static om/Ident\n  <span class=\"token punctuation\">(</span>ident <span class=\"token punctuation\">[</span>this <span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span>id <span class=\"token keyword\">children</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">if-not</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">nil?</span> <span class=\"token keyword\">children</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">[</span><span class=\"token operator\">:composite</span> id<span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">[</span><span class=\"token operator\">:leaf</span> id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  static om/IQuery\n  <span class=\"token punctuation\">(</span>query <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">{</span><span class=\"token operator\">:leaf</span> <span class=\"token punctuation\">(</span>om/get-query Leaf<span class=\"token punctuation\">)</span>\n     <span class=\"token operator\">:composite</span> <span class=\"token punctuation\">(</span>om/get-query Composite<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>We will need a root component, which we will call <code class=\"language-text\">CompositeApp</code>. This one helps define the union query in <code class=\"language-text\">Component</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">(</span>defui CompositeApp\n  static om/IQuery\n  <span class=\"token punctuation\">(</span>query <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span><span class=\"token operator\">:composite</span>/item <span class=\"token punctuation\">(</span>om/get-query Component<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Once we have properly implemented our parser and render methods, we get the following result, which is exactly what we intended. Squares that contain other squares.</p>\n<div style=\"margin-bottom: 20px;\">\n  <div id=\"dp-card-2\"></div>\n</div>\n<p>You can find the complete source code for this post <a href=\"https://gist.github.com/anmonteiro/2b282aa35380558a8b1d#file-composite-cljs\">here</a>.</p>\n<p>In the next post we will talk about the <a href=\"https://en.wikipedia.org/wiki/Decorator_pattern\">Decorator</a> design pattern. Stay tuned!</p>\n<hr>\n<p><sup><sub>1</sub></sup> <sub>these components are not really heterogeneous in the sense that they only differ in the <code class=\"language-text\">children</code> attribute and we could get away with just one component (a leaf would be an item without children). However, the purpose here is to demonstrate the Composite design pattern and, as such, we'll be a little more verbose.</sub></p>\n<p><sup><sub>2</sub></sup> <sub>render methods are omitted for brevity.</sub></p>\n<p><sup><sub>3</sub></sup> <sub>at the time of this writing, you'll need to clone Om Next from master and install it in your local repository in order to run the example code</sub></p>\n<script type=\"text/javascript\" src=\"/js/exploration-dp-1.js\"></script>","fields":{"title":"An Exploration of Object Recursion Design Patterns with Om Next Recursive Queries - Part 1","date":"07 Jan 2016","tags":["clojure","clojurescript","om"],"slug":"/2016/01/exploration-patterns-om-next-part-1/","url":"https://anmonteiro.com/2016/01/exploration-patterns-om-next-part-1/"}},"allPosts":{"edges":[{"node":{"fields":{"title":"On OCaml and the JS platform","slug":"/2021/12/on-ocaml-and-the-js-platform/","tags":["reason","ocaml","rescript"],"date":"11 Dec 2021"}}},{"node":{"fields":{"title":"Reason and the Language Server Protocol: The Landscape","slug":"/2018/11/reason-and-the-language-server-protocol-the-landscape/","tags":["reason","ocaml","emacs","editors"],"date":"17 Nov 2018"}}},{"node":{"fields":{"title":"The State of ClojureScript Compilation in Lumo","slug":"/2017/09/the-state-of-clojurescript-compilation-in-lumo/","tags":["clojure","clojurescript","lumo"],"date":"19 Sep 2017"}}},{"node":{"fields":{"title":"Shipping a (very simplistic) ReasonReact app","slug":"/2017/08/shipping-a-very-simplistic-reasonreact-app/","tags":["reason","ocaml"],"date":"20 Aug 2017"}}},{"node":{"fields":{"title":"On Lumo's Growth and Sustainability","slug":"/2017/05/on-lumos-growth-and-sustainability/","tags":["clojure","clojurescript","lumo"],"date":"01 May 2017"}}},{"node":{"fields":{"title":"Requiring Node.js modules from ClojureScript namespaces","slug":"/2017/03/requiring-node-js-modules-from-clojurescript-namespaces/","tags":["clojure","clojurescript","node","nodejs"],"date":"17 Mar 2017"}}},{"node":{"fields":{"title":"Compiling ClojureScript Projects Without the JVM","slug":"/2017/02/compiling-clojurescript-projects-without-the-jvm/","tags":["clojure","clojurescript","lumo"],"date":"21 Feb 2017"}}},{"node":{"fields":{"title":"The fastest Clojure REPL in the world","slug":"/2016/11/the-fastest-clojure-repl-in-the-world/","tags":["clojure","clojurescript","lumo"],"date":"09 Nov 2016"}}},{"node":{"fields":{"title":"ClojureScript `require` outside `ns`","slug":"/2016/10/clojurescript-require-outside-ns/","tags":["clojure","clojurescript"],"date":"02 Oct 2016"}}},{"node":{"fields":{"title":"Om Next internals: Incremental Rendering","slug":"/2016/09/om-next-internals-incremental-rendering/","tags":["clojure","clojurescript","om"],"date":"29 Sep 2016"}}},{"node":{"fields":{"title":"Om Next Server-Side Rendering","slug":"/2016/09/om-next-server-side-rendering/","tags":["clojure","clojurescript","om"],"date":"15 Sep 2016"}}},{"node":{"fields":{"title":"Om Next at Full Stack Fest 2016","slug":"/2016/09/om-next-at-full-stack-fest-2016/","tags":["talks","clojure","clojurescript","om"],"date":"14 Sep 2016"}}},{"node":{"fields":{"title":"Om Next and Bootstrapped ClojureScript","slug":"/2016/08/om-next-and-bootstrapped-clojurescript/","tags":["clojure","clojurescript","om"],"date":"24 Aug 2016"}}},{"node":{"fields":{"title":"ClojureScript `require` now supports `:rename`","slug":"/2016/08/clojurescript-require-now-supports-rename/","tags":["clojure","clojurescript"],"date":"10 Aug 2016"}}},{"node":{"fields":{"title":"The quest for a unified routing solution in Om Next","slug":"/2016/06/the-quest-for-a-unified-routing-solution-in-om-next/","tags":["clojure","clojurescript","om"],"date":"12 Jun 2016"}}},{"node":{"fields":{"title":"&apos;Clients in control&apos; — Om Next at Craft Conference 2016","slug":"/2016/05/clients-in-control-om-next-craft-conf-2016/","tags":["talks","clojure","clojurescript","om"],"date":"14 May 2016"}}},{"node":{"fields":{"title":"Routing in Om Next — a Catalog of Approaches","slug":"/2016/02/routing-in-om-next-a-catalog-of-approaches/","tags":["clojure","clojurescript","om"],"date":"22 Feb 2016"}}},{"node":{"fields":{"title":"Om Next meets Devcards — the full reloadable experience","slug":"/2016/02/om-next-meets-devcards-the-full-reloadable-experience/","tags":["clojure","clojurescript","om"],"date":"01 Feb 2016"}}},{"node":{"fields":{"title":"Writing Om Next Reloadable Code — A Checklist","slug":"/2016/01/writing-om-next-reloadable-code-a-checklist/","tags":["clojure","clojurescript","om"],"date":"21 Jan 2016"}}},{"node":{"fields":{"title":"An Exploration of Object Recursion Design Patterns with Om Next Recursive Queries - Part 2","slug":"/2016/01/exploration-patterns-om-next-part-2/","tags":["clojure","clojurescript","om"],"date":"09 Jan 2016"}}},{"node":{"fields":{"title":"An Exploration of Object Recursion Design Patterns with Om Next Recursive Queries - Part 1","slug":"/2016/01/exploration-patterns-om-next-part-1/","tags":["clojure","clojurescript","om"],"date":"07 Jan 2016"}}},{"node":{"fields":{"title":"Om Next Query Syntax Explained","slug":"/2016/01/om-next-query-syntax/","tags":["clojure","clojurescript","om"],"date":"04 Jan 2016"}}},{"node":{"fields":{"title":"Om Next Study Material","slug":"/2015/12/om-next-study-material/","tags":["clojure","clojurescript","om"],"date":"10 Dec 2015"}}},{"node":{"fields":{"title":"clj-isitup - a simple isitup.org API client","slug":"/2015/11/clj-isitup-a-simple-isitup-org-api-client/","tags":["clojure"],"date":"17 Nov 2015"}}},{"node":{"fields":{"title":"Hosting files on the cloud via GitHub Issues","slug":"/2015/09/hosting-files-on-the-cloud-via-github-issues/","tags":["git","GitHub"],"date":"26 Sep 2015"}}},{"node":{"fields":{"title":"Solving Closure Library's Html5history double event dispatch","slug":"/2015/09/solving-closure-librarys-html5history-double-event-dispatch/","tags":["clojure","clojurescript"],"date":"11 Sep 2015"}}},{"node":{"fields":{"title":"Setting up Heroku config variables with Clojure","slug":"/2015/09/setting-up-heroku-config-variables-with-clojure/","tags":["clojure","heroku"],"date":"03 Sep 2015"}}},{"node":{"fields":{"title":"Jekyll related posts revamped","slug":"/2015/08/jekyll-related-posts-revamped/","tags":["jekyll"],"date":"29 Aug 2015"}}},{"node":{"fields":{"title":"Custom subdomains in GitHub project pages","slug":"/2015/08/custom-subdomains-in-github-project-pages/","tags":["git","GitHub"],"date":"24 Aug 2015"}}},{"node":{"fields":{"title":"Grand opening","slug":"/2015/08/grand-opening/","tags":["lifestyle"],"date":"18 Aug 2015"}}},{"node":{"fields":{"title":"On OCaml and the JS platform","slug":"/2021/12/on-ocaml-and-the-js-platform/","tags":["reason","ocaml","rescript"],"date":"12 Dec 2021"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2016/01/exploration-patterns-om-next-part-1/"}}