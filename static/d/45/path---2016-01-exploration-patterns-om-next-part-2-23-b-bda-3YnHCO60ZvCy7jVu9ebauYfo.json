{"data":{"markdownRemark":{"excerpt":"\nThis is part two of a series of posts that aim to demonstrate how to build classical Software Engineering object recursion patterns in Om Next. In the [previous post](2016/01/exploration-patterns-om-next-part-1), we explored the Om Next constructs of the Composite. This time around we will use the [Decorator](https://en.wikipedia.org/wiki/Decorator_pattern) design pattern to build a simple component hierarchy that provides runtime extensibility.\n\n","html":"<p>This is part two of a series of posts that aim to demonstrate how to build classical Software Engineering object recursion patterns in Om Next. In the <a href=\"2016/01/exploration-patterns-om-next-part-1\">previous post</a>, we explored the Om Next constructs of the Composite. This time around we will use the <a href=\"https://en.wikipedia.org/wiki/Decorator_pattern\">Decorator</a> design pattern to build a simple component hierarchy that provides runtime extensibility.</p>\n<!--more-->\n<h2>The Decorator design pattern</h2>\n<div style=\"max-width:75%;margin:15px auto 0;\">\n  <img src=\"https://cloud.githubusercontent.com/assets/661909/12217911/81cb227e-b70f-11e5-814e-fa564fe5c021.png\" alt=\"Decorator design pattern\">\n</div>\n<p>As with the Composite, the Decorator also appears in the <a href=\"https://en.wikipedia.org/wiki/Design_Patterns\">Gang of Four book</a>. It can be viewed as a restricted form of the Composite (1-Recursion <em>vs</em> Composite's n-Recursion), although it serves a different purpose. The Decorator's aim is to add — or remove — functionality (<em>decorate</em>) to an object at runtime. The same can be achieved by subclassing, although that approach will only provide compile-time extensibility. As can be perceived by the diagram above, several decorators can form a chain, with each new decorator providing a new piece of functionality. The core object lies at the end of the decorator chain.</p>\n<h2>The example</h2>\n<p>If you have read my <a href=\"2016/01/exploration-patterns-om-next-part-1\">last post</a>, you saw that we built an example that rendered squares inside other squares. The example we will build today will also have a geometric square — our core object — and we are going to add functionality that decorates it with pieces of text and/or images.\nWe adopt the nomenclature present in the pattern diagram, except for our concrete decorators, which we will call <code class=\"language-text\">TextDecorator</code> and <code class=\"language-text\">ImageDecorator</code>. Other than that, we need to define components for the <code class=\"language-text\">ConcreteComponent</code> and <code class=\"language-text\">Component</code>. The former implements the square rendering functionality, while the latter is responsible for combining the queries of both decorators and the core — <code class=\"language-text\">ConcreteComponent</code>.</p>\n<h3>The data</h3>\n<p>The core object is just a representation of the square: its <code class=\"language-text\">width</code>, <code class=\"language-text\">height</code> and the <code class=\"language-text\">color</code>. Here's how it looks like:</p>\n<div style=\"margin-bottom: 20px;\">\n  <div id=\"dp-card-1\"></div>\n</div>\n<p>Now, the data in our decorators is quite similar to the Composite case, in the sense that it is recursive. However, since the Decorator pattern employs 1-ObjectRecursion, each data item in this example doesn't have a vector of children, but solely a \"pointer\" to the next decorator. As you can see below, we call this pointer <code class=\"language-text\">:next</code>. Notice how the data that represents the square is the end of the recursion.</p>\n<div style=\"margin-bottom: 20px;\">\n  <div id=\"dp-card-2\"></div>\n</div>\n<h3>The Om Next components (<em>or</em>: \"Show me some code!\")</h3>\n<p>We start by defining our <code class=\"language-text\">ConcreteComponent</code>. Its query is quite simple: the square's attributes.</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">(</span>defui ConcreteComponent\n  static om/IQuery\n  <span class=\"token punctuation\">(</span>query <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    '<span class=\"token punctuation\">[</span><span class=\"token operator\">:id</span> <span class=\"token operator\">:width</span> <span class=\"token operator\">:height</span> <span class=\"token operator\">:color</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The concrete decorators are presented below. They each query for their own set of attributes; those represent the functionality they add to the core object. The only attributes our concrete decorators have in common are the <code class=\"language-text\">id</code> by which they are identified, and the recursion query (<code class=\"language-text\">{:next ...}</code>) which simply tells Om Next that we are expecting to find an object of the same type under that entry <sup><sub>1</sub></sup>.</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">(</span>defui ImageDecorator\n  static om/IQuery\n  <span class=\"token punctuation\">(</span>query <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    '<span class=\"token punctuation\">[</span><span class=\"token operator\">:id</span> <span class=\"token operator\">:decorator</span>/image <span class=\"token operator\">:image</span>/max-width <span class=\"token punctuation\">{</span><span class=\"token operator\">:next</span> <span class=\"token keyword\">..</span>.<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span>defui TextDecorator\n  static om/IQuery\n  <span class=\"token punctuation\">(</span>query <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    '<span class=\"token punctuation\">[</span><span class=\"token operator\">:id</span> <span class=\"token operator\">:decorator</span>/text <span class=\"token punctuation\">{</span><span class=\"token operator\">:next</span> <span class=\"token keyword\">..</span>.<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>How should <code class=\"language-text\">Component</code> be defined, then? Just like in the Decorator pattern diagram, it sits on top of our hierarchy, and delegates functionality to its child components. As such, it needs to aggregate the queries of all the children and define their identity. Our <code class=\"language-text\">Ident</code>s are defined using the following approach. We know that <code class=\"language-text\">TextDecorator</code>s have a <code class=\"language-text\">:decorator/text</code> attribute and <code class=\"language-text\">ImageDecorator</code>s have a <code class=\"language-text\">:decorator/image</code> attribute. If we find none in <code class=\"language-text\">props</code>, we are in the presence of the core object itself. <code class=\"language-text\">Component</code> is shown below.</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">(</span>defui Component\n  static om/Ident\n  <span class=\"token punctuation\">(</span>ident <span class=\"token punctuation\">[</span>this <span class=\"token punctuation\">{</span><span class=\"token operator\">:keys</span> <span class=\"token punctuation\">[</span>id decorator/text decorator/image<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">cond</span>\n      <span class=\"token punctuation\">(</span><span class=\"token keyword\">not</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">nil?</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">:text</span> id<span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">(</span><span class=\"token keyword\">not</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">nil?</span> image<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">:image</span> id<span class=\"token punctuation\">]</span>\n      <span class=\"token operator\">:else</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">:component</span> id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  static om/IQuery\n  <span class=\"token punctuation\">(</span>query <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">{</span><span class=\"token operator\">:text</span> <span class=\"token punctuation\">(</span>om/get-query TextDecorator<span class=\"token punctuation\">)</span>\n     <span class=\"token operator\">:image</span> <span class=\"token punctuation\">(</span>om/get-query ImageDecorator<span class=\"token punctuation\">)</span>\n     <span class=\"token operator\">:component</span> <span class=\"token punctuation\">(</span>om/get-query ConcreteComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The last piece of our example is a component that contains the top-level query which finalizes the definition of the union query. This is also our root component. We will call it <code class=\"language-text\">DecoratorApp</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"clojure\"><pre class=\"language-clojure\"><code class=\"language-clojure\"><span class=\"token punctuation\">(</span>defui DecoratorApp\n  static om/IQuery\n  <span class=\"token punctuation\">(</span>query <span class=\"token punctuation\">[</span>this<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span><span class=\"token operator\">:decorator</span>/app <span class=\"token punctuation\">(</span>om/get-query Component<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2>The end result</h2>\n<p>After we implement our Om parser and render methods, we see the final result. The card below shows the result of passing only the square data to the example we just built. Pretty boring, heh? Scroll down!</p>\n<div style=\"margin-bottom: 20px;\">\n  <div id=\"dp-card-3\"></div>\n</div>\n<p>However, if we pass the state that contains our decorators, we see that the previously boring square has been decorated with that data! One more thing: if you simply supply data that has more (or less, for that case) decorators to our example, those will be reflected in our core object. We have thus achieved runtime extensibility.</p>\n<div style=\"margin-bottom: 20px;\">\n  <div id=\"dp-card-4\"></div>\n</div>\n<p>The complete source code for this post is published in this <a href=\"https://gist.github.com/anmonteiro/2b282aa35380558a8b1d#file-decorator-cljs\">gist</a>.</p>\n<p>Thanks for reading!</p>\n<hr>\n<p><sup><sub>1</sub></sup> <sub>here, \"an object of the same type\" refers to any one that the union query satisfies (which might not share the same query). Simple recursion can also be specified in Om Next, which allows to strictly recurse into an object which has the exact same query. For tips on how to use that syntax, visit <a href=\"2016/01/om-next-query-syntax\">my post</a> on that topic</sub></p>\n<script type=\"text/javascript\" src=\"/js/exploration-dp-2.js\"></script>","fields":{"title":"An Exploration of Object Recursion Design Patterns with Om Next Recursive Queries - Part 2","date":"09 Jan 2016","tags":["clojure","clojurescript","om"],"slug":"/2016/01/exploration-patterns-om-next-part-2/","url":"https://anmonteiro.com/2016/01/exploration-patterns-om-next-part-2/"}},"allPosts":{"edges":[{"node":{"fields":{"title":"On OCaml and the JS platform","slug":"/2021/12/on-ocaml-and-the-js-platform/","tags":["reason","ocaml","rescript"],"date":"11 Dec 2021"}}},{"node":{"fields":{"title":"Reason and the Language Server Protocol: The Landscape","slug":"/2018/11/reason-and-the-language-server-protocol-the-landscape/","tags":["reason","ocaml","emacs","editors"],"date":"17 Nov 2018"}}},{"node":{"fields":{"title":"The State of ClojureScript Compilation in Lumo","slug":"/2017/09/the-state-of-clojurescript-compilation-in-lumo/","tags":["clojure","clojurescript","lumo"],"date":"19 Sep 2017"}}},{"node":{"fields":{"title":"Shipping a (very simplistic) ReasonReact app","slug":"/2017/08/shipping-a-very-simplistic-reasonreact-app/","tags":["reason","ocaml"],"date":"20 Aug 2017"}}},{"node":{"fields":{"title":"On Lumo's Growth and Sustainability","slug":"/2017/05/on-lumos-growth-and-sustainability/","tags":["clojure","clojurescript","lumo"],"date":"01 May 2017"}}},{"node":{"fields":{"title":"Requiring Node.js modules from ClojureScript namespaces","slug":"/2017/03/requiring-node-js-modules-from-clojurescript-namespaces/","tags":["clojure","clojurescript","node","nodejs"],"date":"17 Mar 2017"}}},{"node":{"fields":{"title":"Compiling ClojureScript Projects Without the JVM","slug":"/2017/02/compiling-clojurescript-projects-without-the-jvm/","tags":["clojure","clojurescript","lumo"],"date":"21 Feb 2017"}}},{"node":{"fields":{"title":"The fastest Clojure REPL in the world","slug":"/2016/11/the-fastest-clojure-repl-in-the-world/","tags":["clojure","clojurescript","lumo"],"date":"09 Nov 2016"}}},{"node":{"fields":{"title":"ClojureScript `require` outside `ns`","slug":"/2016/10/clojurescript-require-outside-ns/","tags":["clojure","clojurescript"],"date":"02 Oct 2016"}}},{"node":{"fields":{"title":"Om Next internals: Incremental Rendering","slug":"/2016/09/om-next-internals-incremental-rendering/","tags":["clojure","clojurescript","om"],"date":"29 Sep 2016"}}},{"node":{"fields":{"title":"Om Next Server-Side Rendering","slug":"/2016/09/om-next-server-side-rendering/","tags":["clojure","clojurescript","om"],"date":"15 Sep 2016"}}},{"node":{"fields":{"title":"Om Next at Full Stack Fest 2016","slug":"/2016/09/om-next-at-full-stack-fest-2016/","tags":["talks","clojure","clojurescript","om"],"date":"14 Sep 2016"}}},{"node":{"fields":{"title":"Om Next and Bootstrapped ClojureScript","slug":"/2016/08/om-next-and-bootstrapped-clojurescript/","tags":["clojure","clojurescript","om"],"date":"24 Aug 2016"}}},{"node":{"fields":{"title":"ClojureScript `require` now supports `:rename`","slug":"/2016/08/clojurescript-require-now-supports-rename/","tags":["clojure","clojurescript"],"date":"10 Aug 2016"}}},{"node":{"fields":{"title":"The quest for a unified routing solution in Om Next","slug":"/2016/06/the-quest-for-a-unified-routing-solution-in-om-next/","tags":["clojure","clojurescript","om"],"date":"12 Jun 2016"}}},{"node":{"fields":{"title":"&apos;Clients in control&apos; — Om Next at Craft Conference 2016","slug":"/2016/05/clients-in-control-om-next-craft-conf-2016/","tags":["talks","clojure","clojurescript","om"],"date":"14 May 2016"}}},{"node":{"fields":{"title":"Routing in Om Next — a Catalog of Approaches","slug":"/2016/02/routing-in-om-next-a-catalog-of-approaches/","tags":["clojure","clojurescript","om"],"date":"22 Feb 2016"}}},{"node":{"fields":{"title":"Om Next meets Devcards — the full reloadable experience","slug":"/2016/02/om-next-meets-devcards-the-full-reloadable-experience/","tags":["clojure","clojurescript","om"],"date":"01 Feb 2016"}}},{"node":{"fields":{"title":"Writing Om Next Reloadable Code — A Checklist","slug":"/2016/01/writing-om-next-reloadable-code-a-checklist/","tags":["clojure","clojurescript","om"],"date":"21 Jan 2016"}}},{"node":{"fields":{"title":"An Exploration of Object Recursion Design Patterns with Om Next Recursive Queries - Part 2","slug":"/2016/01/exploration-patterns-om-next-part-2/","tags":["clojure","clojurescript","om"],"date":"09 Jan 2016"}}},{"node":{"fields":{"title":"An Exploration of Object Recursion Design Patterns with Om Next Recursive Queries - Part 1","slug":"/2016/01/exploration-patterns-om-next-part-1/","tags":["clojure","clojurescript","om"],"date":"07 Jan 2016"}}},{"node":{"fields":{"title":"Om Next Query Syntax Explained","slug":"/2016/01/om-next-query-syntax/","tags":["clojure","clojurescript","om"],"date":"04 Jan 2016"}}},{"node":{"fields":{"title":"Om Next Study Material","slug":"/2015/12/om-next-study-material/","tags":["clojure","clojurescript","om"],"date":"10 Dec 2015"}}},{"node":{"fields":{"title":"clj-isitup - a simple isitup.org API client","slug":"/2015/11/clj-isitup-a-simple-isitup-org-api-client/","tags":["clojure"],"date":"17 Nov 2015"}}},{"node":{"fields":{"title":"Hosting files on the cloud via GitHub Issues","slug":"/2015/09/hosting-files-on-the-cloud-via-github-issues/","tags":["git","GitHub"],"date":"26 Sep 2015"}}},{"node":{"fields":{"title":"Solving Closure Library's Html5history double event dispatch","slug":"/2015/09/solving-closure-librarys-html5history-double-event-dispatch/","tags":["clojure","clojurescript"],"date":"11 Sep 2015"}}},{"node":{"fields":{"title":"Setting up Heroku config variables with Clojure","slug":"/2015/09/setting-up-heroku-config-variables-with-clojure/","tags":["clojure","heroku"],"date":"03 Sep 2015"}}},{"node":{"fields":{"title":"Jekyll related posts revamped","slug":"/2015/08/jekyll-related-posts-revamped/","tags":["jekyll"],"date":"29 Aug 2015"}}},{"node":{"fields":{"title":"Custom subdomains in GitHub project pages","slug":"/2015/08/custom-subdomains-in-github-project-pages/","tags":["git","GitHub"],"date":"24 Aug 2015"}}},{"node":{"fields":{"title":"Grand opening","slug":"/2015/08/grand-opening/","tags":["lifestyle"],"date":"18 Aug 2015"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2016/01/exploration-patterns-om-next-part-2/"}}